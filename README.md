# fingergame
a fingergame called 1 plus 1
周末比较无聊(主要是不想写作业) ，就想到了小时候经常和别人玩的碰手指游戏。高中一个哥们深谙此术，我基本上没赢过...当时我就想有没有什么比较好的方法提高胜率，奈何数学知识有限，到现在我也没有弄明白。昨天心血来潮突然想写个程序试试，但是没学过数据结构和博弈论，网上也参考了一些大佬的idea，恕我才识浅薄没看懂...

不过还是在这贴出来，有兴趣的同学可以去瞅瞅
用Python找到"碰手游戏"的必胜策略
https://mp.weixin.qq.com/s?__biz=MzIzNTkzMTk0Mw==&mid=2247483830&idx=1&sn=fb272caac22280e6ea20fa2e5a4e28c0&chksm=e8ded1fedfa958e8767578ddbabaec7bde61a0a724e17c9e149a882c72e3558efe9cd381045d&scene=0&ascene=7&devicetype=android-27&version=2607023a&nettype=cmnet&abtest_cookie=BAABAAoACwANABMABAAjlx4AWZkeAH2ZHgCAmR4AAAA%3D&lang=zh_CN&pass_ticket=6TawLKDLdaiF9MU0rcLr2ncqrXv0Vk2DpMBRSUGbdXH1FhH1g09uIgU66zbxu3OP&wx_header=1

“碰手游戏”及其完全解决
https://zhuanlan.zhihu.com/p/58014884

其中第一篇和我们讨论的游戏规则略有不同，但两篇的共性是：我都看不懂：）
好啦废话少说，先介绍一下我们讨论的这个游戏的规则：
1.两人四只手，开始时均为1，先手选择自己的左右手之一和对方左右手之一相碰
2.碰后先手碰的那只手变为两数之和的个位，若凑齐0则可以“走”一只手
3.先手操作完后，后手变先手，操作同上
4.谁先“走”完两只手谁赢
貌似各个地方的游戏规则不太一样，我就玩过三种不一样版本的，不过据我看来还是这一种居多（小声吐槽
刚开始的思路是比较简单粗暴的,就是想把所有的情况做成一个数据库形式。因为我觉得总情况数应该不会太多，后来发现我错了...玩了这么久居然没发现这个游戏是可以平局的！（以下是对全文的一个设定：为方便起见，“先手左手+先手右手+后手左手+后手右手”上的数字组成一个四位数，下文均用此四位数代替某个游戏状态）比如 
0206  0806   0804   0204   0206 
就是一个循环，还有其他的一些难点，比如在没有建立树结构的情况下，如何方便的找到父子元素的关系，想了想最后放弃了，这个方法可行性不强，并且动不动还会超出最大递归限度

思来想去，我想到了另一种方法，就是只追溯所有元素的子元素，用列表去表示这样一种数据库关系，比如 定义列表bigdata['1234'] = ['4234','5234','4351','4361'],就是说12 先手 34 后手的时候，先手操作一次之后情况是这四种，当然也有可能重复或者已经“走”了一只手，所以有可能是三种两种一种，也可能是已经赢了或者输了，比如'2400'明显就是先手输了，因为后手两只手已经“走”完了，所以 bigdata['2400'] = ['NN']  (这个"NN"是我自己随便找的一个符号，知道它表示没有，表示完结就行了。）这个步骤丢给计算机还是不难的，稍微分一下类，去一下重就好了。

好了，现在我们得到了一个列表bigdata，这里面的第 k 项就正好对应一个四位数的游戏状态，利用二维数组可以方便的通过父元素获取子元素，这一点正是我们想要的。如前所述，既然我们很难遍历所有情况，那我们应该用什么样的方法呢？我想到了棋类游戏里面关于棋力的说法（不是 其实是千层饼 x）衡量棋力的重要标准就是预判棋局，能提前推演之后的局面，找出胜率最高的方案，所以我也准备这么干。


比如说，我想预判10步，那你输入之后要找bigdata[num][i]中的每一个，对每一个数字，再把它看成新的num，带入继续找bigdata[num][i]，如是往复数十，显然应该用迭代啊...但这是一个循环里套迭代，并且考虑的都是先手，而在实际中先后手是会互换的，并且考虑迭代的时候还要排除刚才所言已经结束（列表中不是数字，是'NN'）的情况，我凌乱了...

想了很久之后想到了一个很棒的主意，第一点循环里套迭代虽然没试过，但是10步肯定不会超出迭代限度，是技术问题；第二点就比较硬伤了...难道真有一个人不动，另一个人疯狂输出的对弈游戏吗？？？


我琢磨了一下，发现这个大坑居！然！可！以！补！上！因为先手和后手各自本身的左右手位置关系并不重要，比如'2345'和'3245','2354','3254'都没啥区别，无非是换换手，但是可以选则的方法都是一样的，所以在对换先手和后手的时候根本不需要乱七八糟的操作（我尤其不喜欢在一个复杂的迭代函数里面再加不必要的东西，因为debug起来实在太痛苦)，直接反转字符串就行了！原来的'NN'这个坑也补上了，只需要在迭代函数开始的时候判断是不是'NN'就好了，这样'NN'就不会进入下一层迭代里面，达到了自动结束已经有结果的分支的目的。


最后就是比对胜率啦，既然要比对胜率，就要规定一下胜率怎么算...我比较懒没有设置权重，所有获胜   +1，所有失败   +1，最后为了排除总量的影响用   就好啦
对了，顺带一提，先手只能在1,3,5,7,9盘获胜，后手只能在2,4,6,8,10盘获胜，所以算flag的时候可以简化一下。

至于怎么玩...就是人先手机器后手，或者给机器残局也可以...比较懒不想优化，反正我试了很多盘没赢过...（

敲了好久，喜欢的话可以点个star再走鸭
